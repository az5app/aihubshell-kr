#!/bin/bash

echo "=========================================="
echo "aihubshell version 25.02.12 v0.5.1"
echo "=========================================="

# 상수정의
BASE_URL="https://api.aihub.or.kr"
LOGIN_URL="$BASE_URL/api/keyValidate.do"
BASE_DOWNLOAD_URL="$BASE_URL/down/0.5"
MANUAL_URL="$BASE_URL/info/api.do"
BASE_FILETREE_URL="$BASE_URL/info"
DATASET_URL="$BASE_URL/info/dataset.do"

# 사용법 출력 함수
print_usage() {
    manual=$(curl -s "$MANUAL_URL")
    # echo -e "$manual"

    echo $manual | grep -oP '"SJ":"\K[^"]+' | head -n 1
    echo -e '\n'
    # 제목 출력
    echo -e "ENGL_CMGG\t KOREAN_CMGG\t\t\t DETAIL_CN"

    # 데이터 처리 및 출력
    echo "$manual" | awk -F'"' -v RS='},' '
    /ENGL_CMGG/ && /KOREAN_CMGG/ && /DETAIL_CN/ {
        for(i=1; i<=NF; i++) {
            if($i == "ENGL_CMGG") engl=$(i+2)
            if($i == "KOREAN_CMGG") korean=$(i+2)
            if($i == "DETAIL_CN") {
                detail=$(i+2)
                gsub(/\\n/, "\n", detail)
                gsub(/\\t/,"\t\t", detail)
                gsub(/\\/,"", detail)
            }
        }
        printf "%-10s\t %-15s\t|\t %s\n\n", engl, korean, detail
    }'
}

# -help 파라미터가 있는 경우 사용법 출력
if [[ "$1" == "-help" ]]; then
    print_usage
    exit 0
fi

# 파라미터 파싱
while [[ "$#" -gt 0 ]]; do
    case $1 in
      		-aihubapikey) aihubapikey="$2"; shift ;;
        -mode) 
            mode="$2";
            # 만약 mode가 'l'이고 다음 값이 숫자인 경우 datasetkey로 설정
            if [[ "$mode" == "l" ]]; then
                if [[ "$3" =~ ^[0-9]+$ ]]; then
                    datasetkey="$3";
                    shift;
                fi
            fi
            shift;
            ;;
        -datasetkey) datasetkey="$2"; shift ;;
        -filekey) filekeys="$2"; shift ;;
        *) echo "Unknown parameter passed: $1"; exit 1 ;;
    esac
    shift
done

# mode가 'd'인 경우 datasetkey가 필수값인지 체크
if [[ "$mode" == "d" && -z "$datasetkey" ]]; then
    echo "Error: datasetkey is required when mode is 'd'";
    exit 1;
fi

# 환경 변수에서 아이디와 패스워드 읽어오기 (파라미터가 제공되지 않은 경우에만)
aihubapikey=${aihubapikey:-$AIHUB_APIKEY}
filekeys=${filekeys:-"all"}

# mode에 따른 로직 수행
case $mode in
    d)
         cleanup() {
            	if [ -e "download.tar" ]; then
	    			rm "download.tar"
	    			echo -e "\n다운로드가 중단되었습니다."
                fi
    		exit 1          
	     }

	     trap cleanup SIGINT		

	    if [ -e "download.tar" ]; then
			TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
    	    mv "download.tar" "download_$TIMESTAMP.tar"
    	    echo "msg : download.tar 파일이 존재하여 download_$TIMESTAMP.tar로 백업하였습니다."
        fi
 		
	    # filekeys 값을 사용하여 요청 전송 및 zip 다운로드
            DOWNLOAD_URL="$BASE_DOWNLOAD_URL/$datasetkey.do"
            
			# 상세한 출력을 화면에 표시하면서 다운로드를 진행합니다.
			echo "Starting download..."
			curl -L -C - -o "download.tar" -H "apikey:$aihubapikey" "$DOWNLOAD_URL?fileSn=$filekeys"
			curl_exit_code=$?
			
			# curl 종료 코드를 먼저 확인
			if [ $curl_exit_code -eq 0 ]; then
			    # 다운로드된 파일이 존재하고 크기가 0보다 큰지 확인
			    if [ ! -f "download.tar" ] || [ ! -s "download.tar" ]; then
			        echo "Error: Downloaded file is missing or empty"
			        exit 1
			    fi
			    
			    # 파일 크기 출력
			    echo "Download successful. File size: $(du -h download.tar | cut -f1)"
			    
			    # tar 파일 무결성 검증
			    if ! tar -tf download.tar >/dev/null 2>&1; then
			        echo "Error: Downloaded tar file is corrupted"
			        rm -f download.tar
			        exit 1
			    fi
			    
			    echo "Extracting files..."
			    # tar 파일을 해제
                    tar -xvf download.tar

                    echo '잠시 기다려 주세요 병합중 입니다. '
                    merge_parts() {
                        local target_dir="$1"
                        local merged_count=0
                        
                        # 디버깅을 위해 part 파일들 확인
                        echo "Checking for part files in $target_dir"
                        ls -la "$target_dir"/*.part* 2>/dev/null | head -5
                        
                        # 해당 폴더에 있는 모든 part 파일들의 prefix를 찾음
                        # .part0, .part1 형태와 .part00, .part01 형태 모두 처리
                        for part_file in $(find "$target_dir" -maxdepth 1 -name '*.part[0-9]*' -type f | head -1); do
                            # 첫 번째 part 파일에서 prefix 추출
                            # 예: file.zip.part0 -> file.zip
                            prefix=$(echo "$part_file" | sed 's/\.part[0-9]*$//')
                            prefix=$(basename "$prefix")
                            
                            echo "Found part files with prefix: $prefix"
                            
                            # 해당 prefix의 모든 part 파일 확인
                            part_count=$(find "${target_dir}" -maxdepth 1 -name "${prefix}.part*" -type f | wc -l)
                            echo "Total part files for $prefix: $part_count"
                            
                            if [ $part_count -eq 0 ]; then
                                echo "Warning: No part files found for prefix $prefix"
                                continue
                            fi
                            
                            echo "Merging $prefix from $part_count parts"
                            
                            # 임시 파일로 병합
                            temp_file="${target_dir}/${prefix}.tmp"
                            
                            # part 파일들을 숫자 순서대로 정렬하여 병합
                            # .part0, .part1, ... .part10, .part11 순서 보장
                            for part in $(ls "${target_dir}/${prefix}".part* 2>/dev/null | sort -V); do
                                cat "$part" >> "$temp_file"
                            done
                            
                            # 병합된 파일이 비어있지 않은지 확인
                            if [ -s "$temp_file" ]; then
                                mv "$temp_file" "${target_dir}/${prefix}"
                                # 병합이 완료된 후 part 파일들을 삭제
                                rm -f "${target_dir}/${prefix}".part*
                                echo "Successfully merged $prefix ($(du -h "${target_dir}/${prefix}" | cut -f1))"
                                merged_count=$((merged_count + 1))
                            else
                                echo "Error: Merged file $prefix is empty"
                                rm -f "$temp_file"
                            fi
                        done
                        
                        # 남은 part 파일들을 다시 확인 (다른 패턴)
                        for prefix in $(find "$target_dir" -maxdepth 1 -name '*.part[0-9]*' -type f | sed 's/\.part[0-9]*$//' | sort -u); do
                            prefix=$(basename "$prefix")
                            
                            # 이미 처리했으면 건너뛰기
                            if [ -f "${target_dir}/${prefix}" ]; then
                                continue
                            fi
                            
                            echo "Processing additional prefix: $prefix"
                            
                            temp_file="${target_dir}/${prefix}.tmp"
                            for part in $(ls "${target_dir}/${prefix}".part* 2>/dev/null | sort -V); do
                                cat "$part" >> "$temp_file"
                            done
                            
                            if [ -s "$temp_file" ]; then
                                mv "$temp_file" "${target_dir}/${prefix}"
                                rm -f "${target_dir}/${prefix}".part*
                                echo "Successfully merged $prefix ($(du -h "${target_dir}/${prefix}" | cut -f1))"
                                merged_count=$((merged_count + 1))
                            else
                                rm -f "$temp_file"
                            fi
                        done
                        
                        if [ $merged_count -gt 0 ]; then
                            echo "Merged $merged_count files in $target_dir"
                        else
                            echo "No files were merged in $target_dir"
                        fi
                    }

                    # 모든 하위 폴더를 탐색하며 마지막 자식 폴더인 경우에 merge_parts 함수 호출
                    find . -type d | while read -r dir; do
                        if [[ ! -z $(find "$dir" -maxdepth 1 -name '*.part*') ]]; then
                            merge_parts "$dir"
                        fi
                    done

                    # 압축 해제 후 파일 확인
                    extracted_files=$(find . -maxdepth 3 \( -name "*.zip" -o -name "*.json" -o -name "*.csv" -o -name "*.txt" -o -name "*.jpg" -o -name "*.png" \) -type f | head -10)
                    if [ -z "$extracted_files" ]; then
                        echo "Warning: No expected files found after extraction and merging"
                    else
                        echo "Extraction and merging completed successfully. Sample files:"
                        echo "$extracted_files"
                    fi
                    
                    echo '병합이 완료 되었습니다. '
                    rm download.tar
			else
			    echo "Download failed with curl exit code $curl_exit_code."
			    
			    # 에러 메시지 안전하게 출력
			    if [ -f "download.tar" ] && [ -s "download.tar" ]; then
			        echo "Error response:"
			        # 텍스트 파일인지 확인 후 출력
			        if file download.tar 2>/dev/null | grep -q "text\|ASCII"; then
			            head -c 1000 download.tar
			        else
			            echo "(Binary error response - not displaying)"
			        fi
			    fi
			    rm -f download.tar
			    exit 1
			fi
        ;;
    l)
        if [[ $datasetkey ]]; then
            # 파일 트리 구조 요청 및 출력
            FILETREE_URL="$BASE_FILETREE_URL/$datasetkey.do"
            echo "Fetching file tree structure..."
            file_tree=$(curl -s "$FILETREE_URL")
            echo "$file_tree"
        else
            # 데이터셋 조회
            echo "Fetching dataset information..."
            dataset_info=$(curl -s "$DATASET_URL")
            echo "$dataset_info"
        fi
        ;;
    *)
        echo "Invalid mode. Please use 'd', 'l' for dataset list, 'l [datasetkey]' for file tree"
        exit 1
        ;;
esac